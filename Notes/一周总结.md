#学习ReactiveCocoa一周总结

todo:

FRP

RACSignal

热信号在我们生活中有很多的例子，比如订阅杂志时并不会把之前所有的期刊都送到我们手中，只会接收到订阅之后的期刊；而对于冷信号的话，举一个不恰当的例子，每一年的高考考生在『订阅』高考之后，收到往年所有的试卷，并在高考之后会取消订阅。

RACSequence

//signal 和 sequence相互转变 https://www.jianshu.com/p/fea4637706f8

RACSubject  
在大多数情况下，我们也只会使用 RACSubject 自己或者 RACReplaySubject。

RACSubject 在 RACSignal 对象之上进行了简单的修改，将原有的冷信号改造成了热信号，将不可变变成了可变。

虽然 RACSubject 的实现并不复杂，只是存储了一个遵循 RACSubscriber 协议的对象列表以及所有的消息，但是在解决实际问题时却能够很好地解决很多与网络操作相关的问题。

RACDisposable

RACCommand

    _executionSignals = [[[self.addedExecutionSignalsSubject
        map:^(RACSignal *signal) {
            return [signal catchTo:[RACSignal empty]];
        }]
        deliverOn:RACScheduler.mainThreadScheduler]
        setNameWithFormat:@"%@ -executionSignals", self];
        
它只是将信号中的所有的错误 NSError 转换成了 RACEmptySignal 对象，并派发到主线程上。

RACMulticastConnection

Note that you shouldn't create RACMulticastConnection manually. Instead use -[RACSignal publish] or -[RACSignal multicast:].

RACEvent

RACSubscriber

RACScheduler

Operations

Categories

Macro

KVO UIEvent Delegate Notification

---

todo:

bind概念 

racsequence的head tail


---   

    /**
     - subscribeNext:
     1. 创建subscriber
     2.subscribe singal
     
     subscriber的销毁时机是signal sendComplete: 或 sendError:
     */

     // 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。
    // 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。

